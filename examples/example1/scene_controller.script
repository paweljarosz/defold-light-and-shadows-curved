local rendercam = require 'rendercam.rendercam'
local triggers  = require "in.triggers"
local light     = require 'light_and_shadows.light'
local common    = require 'helper.common'
local broadcast = require 'ludobits.m.broadcast'

go.property("cam", msg.url("cam"))
go.property("acquire_delay", 0)
go.property("enable_pan_limits", false)
go.property("pan_min", vmath.vector3(-1, -1, -1))
go.property("pan_max", vmath.vector3(1, 1, 1))
go.property("zoom_in_action_id", hash("mouse_wheel_up"))
go.property("zoom_out_action_id", hash("mouse_wheel_down"))
go.property("zoom_step", 10)
go.property("enable_zoom_limits", false)
go.property("min_zoom", 0.5)
go.property("max_zoom", 1)
go.property("mouse_look_enabled", true)
go.property("mouse_look_sensitivity_deg", 0.25)
go.property("mouse_pitch_min_deg", -40)
go.property("mouse_pitch_max_deg", 20)
go.property("mouse_yaw_min_deg", -35)
go.property("mouse_yaw_max_deg", 35)

-- Scene Input controller.
-- Handle mouse click/touch and broadcast it to listeners.
-- Scroll/zoom a game world by moving the camera.

local function clamp_value(value, min_value, max_value)
    if value < min_value then
        return min_value
    elseif value > max_value then
        return max_value
    end
    return value
end

local function clamp_vector3(vec, min_vec, max_vec)
    return vmath.vector3(
        clamp_value(vec.x, min_vec.x, max_vec.x),
        clamp_value(vec.y, min_vec.y, max_vec.y),
        clamp_value(vec.z, min_vec.z, max_vec.z)
    )
end

local function clamp01(n)
    if n < -1 then return -1 end
    if n > 1 then return 1 end
    return n
end

local FORWARD = vmath.vector3(0, 0, -1)

local function quat_to_yaw_pitch(q)
    -- Derive yaw (around Y) and pitch (around X) from the forward vector; roll is ignored.
    local fwd = vmath.rotate(q, FORWARD)
    local yaw = math.atan2(fwd.x, -fwd.z) -- signed yaw in radians
    local pitch = math.asin(clamp01(fwd.y))
    return yaw, pitch
end

local function apply_yaw_pitch(self)
    local q = vmath.quat_rotation_y(self._cam_yaw) * vmath.quat_rotation_x(self._cam_pitch)
    go.set_rotation(q, self.cam)
end

local function set_camera_position(self, new_position)
    if self.enable_pan_limits then
        new_position = clamp_vector3(new_position, self._pan_min, self._pan_max)
    end
    go.cancel_animations(self.cam, "position")
    go.set_position(new_position, self.cam)
end

function init(self)
    timer.delay(self.acquire_delay, false, function()
        msg.post(".", "acquire_input_focus")
    end)
    self.touch_down = false
    self.swipe_start_time = 0
    self.zoom_step = math.abs(self.zoom_step)
    self._zoom_min = math.min(self.min_zoom, self.max_zoom)
    self._zoom_max = math.max(self.min_zoom, self.max_zoom)
    self._current_zoom_offset = 0
    self._pan_min = vmath.vector3(
        math.min(self.pan_min.x, self.pan_max.x),
        math.min(self.pan_min.y, self.pan_max.y),
        math.min(self.pan_min.z, self.pan_max.z)
    )
    self._pan_max = vmath.vector3(
        math.max(self.pan_min.x, self.pan_max.x),
        math.max(self.pan_min.y, self.pan_max.y),
        math.max(self.pan_min.z, self.pan_max.z)
    )
    -- Mouse-look setup: capture current yaw/pitch as baseline and clamp range.
    local yaw, pitch = quat_to_yaw_pitch(go.get_rotation(self.cam))
    self._cam_yaw = yaw
    self._cam_pitch = pitch
    self._mouse_yaw_min = math.rad(math.min(self.mouse_yaw_min_deg, self.mouse_yaw_max_deg))
    self._mouse_yaw_max = math.rad(math.max(self.mouse_yaw_min_deg, self.mouse_yaw_max_deg))
    self._mouse_pitch_min = math.rad(math.min(self.mouse_pitch_min_deg, self.mouse_pitch_max_deg))
    self._mouse_pitch_max = math.rad(math.max(self.mouse_pitch_min_deg, self.mouse_pitch_max_deg))
    self._mouse_sens = math.rad(self.mouse_look_sensitivity_deg)
    self._right_down = false
end

function final(self)
    msg.post(".", "release_input_focus")
end

function update(self, dt)
    local view = go.get_rotation(self.cam)
    light.cam_view = view
    local pos = go.get_position("cam")
    light.cam_pos = pos
    common.cam_pos = pos
end

local function keyboard_map(self, action_id, action)
    if action_id == triggers.KEY_I and action.released then
        msg.post('@system:', 'toggle_profile')

    elseif action_id == triggers.KEY_O and action.released then 
        msg.post('@system:', 'toggle_physics_debug')
    end
end

local function apply_zoom_delta(self, delta)
    if delta == 0 then
        return
    end

    if not self.enable_zoom_limits then
        rendercam.zoom(delta)
        return
    end

    local proposed_offset = clamp_value(self._current_zoom_offset + delta, self._zoom_min, self._zoom_max)
    local allowed_delta = proposed_offset - self._current_zoom_offset
    if math.abs(allowed_delta) < 0.0001 then
        return
    end
    rendercam.zoom(allowed_delta)
    self._current_zoom_offset = proposed_offset
end

local function zoom(self, action_id, action)
    if self.zoom_step <= 0 then
        return
    end

    local is_zoom_in = (action_id == self.zoom_in_action_id) or (action_id == triggers.KEY_F)
    local is_zoom_out = (action_id == self.zoom_out_action_id) or (action_id == triggers.KEY_G)

    if not is_zoom_in and not is_zoom_out then
        return
    end

    if not (action.pressed or action.repeated) then
        return
    end

    local delta = self.zoom_step
    if is_zoom_out then
        delta = -delta
    end

    apply_zoom_delta(self, delta)
end

local function mouse_look(self, action_id, action)
    if not self.mouse_look_enabled or self._mouse_sens <= 0 then
        return
    end
    local right_btn = hash("mouse_button_right")
    if action_id == right_btn then
        if action.pressed then
            self._right_down = true
        elseif action.released then
            self._right_down = false
        end
        return
    end

    if self._right_down and action_id == nil then
        -- Dragging with RMB adjusts yaw/pitch in a limited range (axes reversed per request).
        self._cam_yaw = clamp_value(self._cam_yaw - action.dx * self._mouse_sens, self._mouse_yaw_min, self._mouse_yaw_max)
        self._cam_pitch = clamp_value(self._cam_pitch + action.dy * self._mouse_sens, self._mouse_pitch_min, self._mouse_pitch_max)
        apply_yaw_pitch(self)
    end
end

local left = hash("mouse_button_left")
function on_input(self, action_id, action)

    keyboard_map(self, action_id, action)
    zoom(self, action_id, action)
    mouse_look(self, action_id, action)
       
    if action_id == left then
        self.touch_down = true
        if action.pressed then
            self.swipe_start_time = socket.gettime()
        end
        if action.released then
            broadcast.send("click", {x = action.screen_x, y = action.screen_y})
            self.touch_down = false
        end
    end
    
    if self.touch_down and action_id == nil then
        local view =  go.get_rotation(self.cam)
        local dx, dy = rendercam.screen_to_viewport(action.dx, action.dy, true)
        local v3 = vmath.vector3(dx, 0, -dy)
        local position = go.get_position(self.cam)
        local v2 = position - vmath.rotate(view, v3)*0.1
        v2.y = position.y
        set_camera_position(self, v2)
    end
    
end
